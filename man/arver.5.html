<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>arver(5) - LUKS on the loose</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#SYNOPSIS">SYNOPSIS</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#OPTIONS">OPTIONS</a>
    <a href="#ACTIONS">ACTIONS</a>
    <a href="#TARGETS">TARGETS</a>
    <a href="#Working-with-arver">Working with arver</a>
    <a href="#Concept">Concept</a>
    <a href="#Bootstrapping-a-new-datastore">Bootstrapping a new datastore</a>
    <a href="#Action-Create">Action Create</a>
    <a href="#Action-Open">Action Open</a>
    <a href="#Action-Close">Action Close</a>
    <a href="#Managing-users">Managing users</a>
    <a href="#Information-about-targets">Information about targets</a>
    <a href="#Garbage-collection">Garbage collection</a>
    <a href="#SEE-ALSO">SEE ALSO</a>
    </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>arver(5)</li>
    <li class='tc'></li>
    <li class='tr'>arver(5)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>arver</code> - <span class="man-whatis">LUKS on the loose</span>
</p>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<pre><code>arver [-u user] [-c datastore] [OPTIONS] -t TARGET ACTION
arver [-u user] [-c datastore] [OPTIONS] ACTION
</code></pre>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>arver is a tool that helps you to manage large amount of encrypted harddisks
over mutliple servers and locations. Furthermore, it helps you to mange
access policies to encrypted harddisks of a bunch of people.</p>

<p>By default <code>arver</code> requires a specific action and (for most actions) a
target to work.</p>

<h2 id="OPTIONS">OPTIONS</h2>

<p>There are some generic command line options:</p>

<dl>
<dt><code>-u USER</code>, <code>--user USER</code></dt><dd>By default <code>arver</code> will read <code>~/.arver</code> to get your username. Using <code>-u USER</code> you can override or specify it aswell.</dd>
<dt><code>-c PATH</code>, <code>--config-dir PATH</code></dt><dd>By default <code>arver</code> will assume your data storage in <code>~/.arverdata</code>. However,
if you have multiple data storage or you want to put it to a different
location you can use the <code>-c PATH</code> option.</dd>
</dl>


<h2 id="ACTIONS">ACTIONS</h2>

<p>The following actions are supported:</p>

<dl>
<dt><code>--create</code></dt><dd>Creates LUKS partitions for <code>arver</code> on all targeted disks.</dd>
<dt><code>-o</code>, <code>--open</code></dt><dd>Opens all targeted disks.</dd>
<dt class="flush"><code>--close</code></dt><dd>Closes all targeted disks.</dd>
<dt><code>-a USER</code>, <code>--add-user USER</code></dt><dd>Adds permissions for USER on all targeted disks.</dd>
<dt><code>--del-user</code></dt><dd>Removes permissions for USER on all targeted disks.</dd>
<dt><code>-i</code>, <code>--info</code></dt><dd>Display the LUKS configuration of all targeted disks.</dd>
<dt><code>-l</code>, <code>--list-targets</code></dt><dd>List all possible targets.</dd>
<dt><code>-g</code>, <code>--garbage-collect</code></dt><dd>Cleans old entries from your <code>arver</code> keys.</dd>
</dl>


<h2 id="TARGETS">TARGETS</h2>

<p>All Targets are defined in the <code>disks</code> config file. See the section
<code>Disks</code> for more details. A complete target looks like this:</p>

<pre><code>/location_name/host_name/disk_name
</code></pre>

<p>But the TARGET option accepts also partial names and lists. E.g</p>

<pre><code>-t location1,location2/host2,host4,disk3
</code></pre>

<p>targets all disks at location1, all disks on host2 at location2, all disks on
host4 and disk3. If any of the provided target names are not unique <code>arver</code> will
quit with an error message stating all matching targets.</p>

<p>To run an action on all possible disks use <code>ALL</code> as target.</p>

<h2 id="Working-with-arver">Working with arver</h2>

<p>Working with arver is quite simple and straight forward. Within the next
paragraphs you'll find a detailed overview on the concept of arver,
as well as how to set it up and what the different actions are doing exactly.</p>

<h2 id="Concept">Concept</h2>

<p>To setup arver we only need to define in the corresponding configuration files our
(admin-)users and our disks.</p>

<p>Arver's configuration files are contained in a single directory which contains all
the necessary (non-private) information to manage your disks. This directory will
be referred to as <code>datastore</code>. We recommend you to share that directory amongs your
group of admins with a distributed version control system such as git.</p>

<p>Eeach admin will be assigned one global LUKS slot. Arver will use this information
to grant or revoke privileges to other users. See the <code>Managing users</code> section
for a detailed descripton of how this is done.</p>

<p>The <code>datastore</code> directory contains the following files and directories:</p>

<pre><code>keys/            &lt;- contains the users `arver` keyrings
keys/public/     &lt;- contains the public keys of all admins
users            &lt;- yaml file containing all users configuration (see `Users`)
disks            &lt;- yaml file containing all disk configuration (see `Disks`)
</code></pre>

<h3 id="Users">Users</h3>

<p>The <code>user</code> config file contains all your admins in the following structure:</p>

<pre><code>foo1: 
  slot: 0
  gpg: BEAFAFFE
foo2:
  slot 1
  gpg: AFFEBEAF
</code></pre>

<p><code>foo1</code> is the identifier of one of your admins. <code>slot</code> referes to the LUKS slot which
is used for this admin. This has to be a unique number between 0 and 7. If you'd like
to migrate existing LUKS devices take care to avoid the currently used slot number
(usually 0). <code>gpg</code> is the gpg-id of the public key for <code>foo1</code>. We recommend to use a
dedicated gpg key just for <code>arver</code>.</p>

<h3 id="Disks">Disks</h3>

<p>The <code>disks</code> file contains the following hash tree in yaml notation:</p>

<pre><code> 'hostgroup1':
   'host1':
     'address' : 'host1.example.com'
     'pre_open': 'pre_open_host_script.sh'
     'disk1'   :
       'device'   : 'storage/disk1'
       'post_open': 'post_open_disk_script.sh'
     'disk2'   : 
       'device'   :  'sdb1'
   'host2':
     'address': 'host2.example.com'
     'port'   : '2222'
     'mails'  : 
       'device'  : 'nonraid/mails'
       'pre_open': 'pre_open_disk_script.sh'
 'hostgroup2':
   'host3':
     'address' : 'host3.example.com'
     'username': 'foo'
     'secure'  : 
       'device'  : 'storage/secure'
</code></pre>

<p>As you can see this allows you to organize your disks and servers in a tree
structure, which will enable you to manage your disks more efficiently within
the later commands.</p>

<p><code>hostgroup1</code> and <code>hostgroup2</code> is just a logical container which can contain any
amount of hosts. You can name them as you like. This is interesting if you have
for example multiple hosts in one location and you need to quickly recover from
a power outage from this location.</p>

<p>Invoking</p>

<pre><code>arver --list-targets
</code></pre>

<p>will present you the tree of the various targets in your <code>disks</code> configuration
file.</p>

<p><code>host1</code>, <code>host2</code> and <code>host3</code> are identifiers for different hosts. These host-
objects can contain multiple disks and can have further information such as the
<code>address</code> of the host or the ssh-<code>port</code> number if the ssh daemon is not running
on the standart port.</p>

<p>You can also add script hooks to any host or disk. Those will be run during the
<code>open</code> and <code>close</code> actions at the appropriate time. The possible options are:
<code>pre_open</code>, <code>pre_close</code>, <code>post_open</code> and <code>post_close</code>.</p>

<p>Any other entry within the hosts-object are actual disks entries of that particular
host. These disks are represented by an identifier and at least a <code>device</code> entry
pointing to the actual disk path. So for example the disks on <code>host1</code> are:
<code>/dev/storage/disk1</code> identified by <code>disk1</code> and <code>/dev/sdb1</code> idetified by <code>disk2</code>.
The prefix <code>/dev/</code> is alays added to the disk path.</p>

<h2 id="Bootstrapping-a-new-datastore">Bootstrapping a new datastore</h2>

<p>How do you start and bootstrap a new <code>datastore</code>, so you can use arver for your
storage?</p>

<p>First you need to create the basic structure for your <code>datastore</code>:</p>

<pre><code>$ mkdir ~/.arverdata # the location is configurable. We use the default one.
$ gpg --gen-key      # create a dedicated gpg key for arver
$ vi users           # add your user and the key-id of your new public gpg-key
$ vi disks           # add your hostgroups, hosts and disks
$ echo "'username': '&lt;your_arver_username>' &gt; ~/.arver  #set your default user
</code></pre>

<p>Then we can create the encrypted harddisk:</p>

<h2 id="Action-Create">Action Create</h2>

<p>To initially create an arver managed LUKS device you first need to add the
device to the disks config. See above for various examples.
You can create the LUKS device by invoking the following command:</p>

<pre><code>$ arver -t TARGET --create 
</code></pre>

<p>What's happening behind the scene?</p>

<p>Arver creates a new LUKS device with a random password in your LUKS slot on the
server. The password is then encrypted with your public key (defined in <code>users</code>)
and stored in <code>datastore/keys/USERNAME/key_X</code></p>

<h2 id="Action-Open">Action Open</h2>

<p>To open a LUKS device managed by arver you can invoke the <code>--open</code> action on any
target:</p>

<pre><code>$ arver -t TARGET --open
</code></pre>

<p>arver retrieves the password by decrypting the keys in data/keys/YOURUSERNAME
and uses this to open the LUKS device on the server.</p>

<p>See the section <code>TARGET</code> on how to open multiple disks at once.</p>

<p>You can define script hooks to be executed before and after the open command.
See <code>Disks</code> for details. The hooks are run in the following order:</p>

<ul>
<li>pre_open of host</li>
<li> pre_open of disk1</li>
<li>  open disk1</li>
<li> post_open of disk1</li>
<li> pre_open of disk2</li>
<li>  open disk2</li>
<li> post_open of disk1</li>
<li>post_open of host</li>
</ul>


<p>Those scripts have to be present at the actual host.</p>

<p>If you don't have a key for any of the disks that you wish to open it will be
skipped (along with its script hooks).</p>

<h2 id="Action-Close">Action Close</h2>

<p>Closing luks devices is simply done by invoking</p>

<pre><code>$ arver -t TARGET
</code></pre>

<p>For this action you can define hooks as well. See <code>Disks</code> and <code>Action Open</code>
for details.</p>

<h2 id="Managing-users">Managing users</h2>

<p>To add another user to one of the disks you need to have the public key of that
user. If you manage your <code>datastore</code> in a version controll system, you'll likely
have the key already in <code>datastore/keys/public/USERNAME</code> where it will be
imported automatically.</p>

<p>Otherwise store it there and add the user to the <code>user</code> config.</p>

<p>Granting the user access to any disk is done by invoking the following command:</p>

<pre><code>$ arver -t TARGET --add-user USERNAME
</code></pre>

<p>For this command to work, you have to trust the gpg key of USERNAME. See
<code>man gpg</code> section --edit-key. You should always verify that you have the correct
key, e.g. by comparing the fingerprint over a trusted channel.</p>

<p>arver will then create a random password for the specific user and add it to
the user-slot on the targeted disks. Furthermore, the password is encrypted
with the public key of the specific user and stored in the data storage under
<code>datastore/keys/USERNAME/</code>.</p>

<p>For the other user to receive those new privileges he has to import the new
keys to his own <code>datastore</code>. So if you use a version controll system you should
now also commit the new keys.</p>

<p>If you are migrating from an existing LUKS infrastructure and want to add an
initial user to the LUKS device, you will need to use the <code>--ask-password</code> option,
to provide an existing password.</p>

<p>To remove all permissions of a certain user you can simply run</p>

<pre><code>$ arver -t TARGET --del-user USERNAME
</code></pre>

<p>Which will remove the password stored in the LUKS slot of that device. Remember
that you can also invoke this command on a whole hostgroup or even on all your
managed devices (using <code>-t ALL</code>). This will help you to quickly and savely
removing any access to encrypted devices of one user immediately amongst the
whole infrastructure.</p>

<p>By design it is not possible to know who has access to which disks by just
looking at the <code>datastore</code>. All arver keys including the information on which
disks they fit are encrypted with the users public key. So without the
corresponding private key it is not possible to see the privileges.</p>

<p>You can however display the targets <code>information</code> to see which slots are used.
But to do this you need access to the server and the <code>users</code> config.</p>

<h2 id="Information-about-targets">Information about targets</h2>

<p>To gather various information about the different targets you can invoke</p>

<pre><code>$ arver -t TARGET -i
</code></pre>

<p>Which will display you the current configuration of all devices, as well as
different parameters of the LUKS device and slot usage.</p>

<h2 id="Garbage-collection">Garbage collection</h2>

<p>As you might add and remove users to disks or reset access to disks the
amount of generated key files with random passwords might grow and not all
might be needed anymore. Furthermore it is likely that due to various
actions it might be obvious or at least reconstructable to which devices a
certain user might have access.</p>

<p>To address this problem arver provides a garbage collection process, which will
rearrange all your own keyfiles. (Only your own as you are not able to read the
others key files.)</p>

<p>You can do that by invoking the following command:</p>

<pre><code>$ arver -gc
</code></pre>

<p>If you use a version controll system to store you <code>datastore</code> you should do this
always before commiting the <code>datastore</code>.</p>

<h2 id="SEE-ALSO">SEE ALSO</h2>

<p><code>cryptsetup</code>(8).
<code>gnupg</code>(7).</p>

<p>Arver project site: <a href="https://git.codecoop.org/projects/arver/" data-bare-link="true">https://git.codecoop.org/projects/arver/</a></p>

<p>YAML website: <a href="http://www.yaml.org/" data-bare-link="true">http://www.yaml.org/</a></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'></li>
    <li class='tc'>February 2011</li>
    <li class='tr'>arver(5)</li>
  </ol>

  </div>
</body>
</html>
